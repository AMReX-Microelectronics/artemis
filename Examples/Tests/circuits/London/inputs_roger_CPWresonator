# We are interested in modeling a CPW resonator with regular conductors.

####################################################################################################
## This input file requires USE_LLG=FALSE in the GNUMakefile.
#################################################################################################

################################
####### GENERAL PARAMETERS ######
#################################
my_constants.nx = 64
my_constants.ny = 1000
my_constants.nz = 320

amr.n_cell = nx ny nz

amr.max_grid_size_x = 64
amr.max_grid_size_y = 250
amr.max_grid_size_z = 160
amr.blocking_factor = 1
amr.max_level = 0

# domain sizes and cell numbers separately defined for easier excitation function definition
my_constants.Lx = 64.0e-6
my_constants.Ly = 2000.0e-7
my_constants.Lz = 16.0e-6

geometry.dims = 3
geometry.prob_lo = -Lx/2 -Ly/2 -Lz/2
geometry.prob_hi =  Lx/2  Ly/2  Lz/2

my_constants.pi = 3.14159265359
my_constants.c = 299792458.

my_constants.dx = Lx / nx
my_constants.dy = Ly / ny
my_constants.dz = Lz / nz
my_constants.ddz = dz / 100
my_constants.ddy = dy / 100

my_constants.th_si = 8.0e-6
my_constants.th_nb = 200.0e-9    # dimensions in z direction

my_constants.gap_cap = 150.0e-7
my_constants.strip_c = 1500.0e-7
my_constants.strip_edge = 100.0e-7     # dimensions in y direction

my_constants.gap_cpw = 6.0e-6
my_constants.w_line = 10.0e-6
my_constants.w_gnd = 21.0e-6      # dimensions in x direction

my_constants.obsx = w_line/2 + gap_cpw/2
my_constants.obsy1 = -strip_c/2 + dy
my_constants.obsy2 = -strip_c/4
my_constants.obsy3 = 0.0
my_constants.obsy4 = strip_c/4
my_constants.obsy5 = strip_c/2 - dy
my_constants.obsz = -Lz/2 + th_si + dz

my_constants.frequency = 86.7e9
my_constants.TP = 1./frequency

my_constants.sigma_nb = 1.e10
my_constants.sigma_0 = 0.0
my_constants.sigma_si = 0.0

my_constants.eps_0 = 8.8541878128e-12
my_constants.eps_r_nb = 1.0
my_constants.eps_r_si = 11.7

my_constants.mu_0 = 1.25663706212e-06
my_constants.mu_r_nb = 1.0
my_constants.mu_r_si = 1.0

my_constants.flag_none = 0 # no source flag
my_constants.flag_hs = 1 # hard source flag
my_constants.flag_ss = 2 # soft source flag

#################################
############ NUMERICS ###########
#################################
warpx.verbose = 1
warpx.use_filter = 0
warpx.cfl = 0.95
boundary.field_lo = pml pml pml
boundary.field_hi = pml pml pml
particles.nspecies = 0

algo.em_solver_medium = macroscopic           # vacuum/macroscopic
algo.macroscopic_sigma_method = backwardeuler   # laxwendroff or backwardeuler

#macroscopic.sigma_function(x,y,z) = "sigma_0"
#macroscopic.epsilon_function(x,y,z) = "eps_0"
#macroscopic.mu_function(x,y,z) = "mu_0"

macroscopic.sigma_function(x,y,z) = "sigma_0
+ (sigma_si - sigma_0) * (z < -Lz/2 + th_si)
+ (sigma_nb - sigma_0) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x > -w_line/2) * (x < w_line/2) * (y > -strip_c/2) * (y < strip_c/2)
+ (sigma_nb - sigma_0) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x > -w_line/2) * (x < w_line/2) * (y < -strip_c/2 - gap_cap)
+ (sigma_nb - sigma_0) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x > -w_line/2) * (x < w_line/2) * (y > strip_c/2 + gap_cap)
+ (sigma_nb - sigma_0) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x < -w_line/2 - gap_cpw)
+ (sigma_nb - sigma_0) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x > +w_line/2 + gap_cpw)"

macroscopic.epsilon_function(x,y,z) = "eps_0
+ eps_0 * (eps_r_si - 1) * (z < -Lz/2 + th_si)
+ eps_0 * (eps_r_nb - 1) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x > -w_line/2) * (x < w_line/2) * (y > -strip_c/2) * (y < strip_c/2)
+ eps_0 * (eps_r_nb - 1) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x > -w_line/2) * (x < w_line/2) * (y < -strip_c/2 - gap_cap)
+ eps_0 * (eps_r_nb - 1) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x > -w_line/2) * (x < w_line/2) * (y > strip_c/2 + gap_cap)
+ eps_0 * (eps_r_nb - 1) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x < -w_line/2 - gap_cpw)
+ eps_0 * (eps_r_nb - 1) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x > +w_line/2 + gap_cpw)"

macroscopic.mu_function(x,y,z) = "mu_0
+ mu_0 * (mu_r_si - 1) * (z < -Lz/2 + th_si)
+ mu_0 * (mu_r_nb - 1) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x > -w_line/2) * (x < w_line/2) * (y > -strip_c/2) * (y < strip_c/2)
+ mu_0 * (mu_r_nb - 1) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x > -w_line/2) * (x < w_line/2) * (y < -strip_c/2 - gap_cap)
+ mu_0 * (mu_r_nb - 1) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x > -w_line/2) * (x < w_line/2) * (y > strip_c/2 + gap_cap)
+ mu_0 * (mu_r_nb - 1) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x < -w_line/2 - gap_cpw)
+ mu_0 * (mu_r_nb - 1) * (z > -Lz/2 + th_si) * (z < -Lz/2 + th_si + th_nb) * (x > +w_line/2 + gap_cpw)"

#################################
############ FIELDS #############
#################################

warpx.E_excitation_on_grid_style = "parse_E_excitation_grid_function"
warpx.Ez_excitation_flag_function(x,y,z) = "flag_none"
warpx.Ey_excitation_flag_function(x,y,z) = "flag_none"
warpx.Ex_excitation_flag_function(x,y,z) = "flag_none + flag_ss * ((x > w_line/2) * (x < w_line/2 + gap_cpw) + (x < -w_line/2) * (x > -w_line/2 - gap_cpw)) * (z < -Lz/2 + th_si + th_nb + ddz) * (z > -Lz/2 + th_si - ddz) * (y > -Ly/2 - ddy) * (y < -Ly/2 + ddy) "

warpx.Ez_excitation_grid_function(x,y,z,t) = "0."
warpx.Ey_excitation_grid_function(x,y,z,t) = "0."
warpx.Ex_excitation_grid_function(x,y,z,t) = "exp(-(t - 2.*TP)**2/(2*TP*TP))*sin(2*pi*t*frequency) * ((x > w_line/2) * (x < w_line/2 + gap_cpw) + (-1.) * (x < -w_line/2) * (x > -w_line/2 - gap_cpw))"
#warpx.Ex_excitation_grid_function(x,y,z,t) = "sin(2*pi*t*frequency) * ((x > w_line/2) * (x < w_line/2 + gap_cpw) + (-1.) * (x < -w_line/2) * (x > -w_line/2 - gap_cpw))"

# Diagnostics

diagnostics.diags_names = diag1 chk
diag1.intervals = 1000
diag1.diag_type = Full
diag1.fields_to_plot = Ex Ey Ez Bx By Bz jx jy jz sigma epsilon mu
#diag1.fields_to_plot = Ex Ey Ez Bx By Bz jx jy jz superconductor sigma epsilon mu Bx_sc By_sc Bz_sc

chk.format = checkpoint
chk.intervals = 100000
chk.diag_type = Full

max_step = 900000
#amr.restart = diags/chk900000

warpx.reduced_diags_names = Eobs1b Eobs2b Eobs3b Eobs4b Eobs5b

Eobs1b.type = RawEFieldReduction
Eobs2b.type = RawEFieldReduction
Eobs3b.type = RawEFieldReduction
Eobs4b.type = RawEFieldReduction
Eobs5b.type = RawEFieldReduction

Eobs1b.reduction_type = integral
Eobs2b.reduction_type = integral
Eobs3b.reduction_type = integral
Eobs4b.reduction_type = integral
Eobs5b.reduction_type = integral

Eobs1b.integration_type = surface
Eobs2b.integration_type = surface
Eobs3b.integration_type = surface
Eobs4b.integration_type = surface
Eobs5b.integration_type = surface

Eobs1b.intervals = 1
Eobs2b.intervals = 1
Eobs3b.intervals = 1
Eobs4b.intervals = 1
Eobs5b.intervals = 1

Eobs1b.surface_normal = Z
Eobs2b.surface_normal = Z
Eobs3b.surface_normal = Z
Eobs4b.surface_normal = Z
Eobs5b.surface_normal = Z

Eobs1b.reduced_function(x,y,z) = (y >  obsy1 - ddy) * (y < obsy1 + ddy) * (x > obsx) * (x < obsx + dx) * (z > obsz - ddz) * (z < obsz + ddz)
Eobs2b.reduced_function(x,y,z) = (y >  obsy2 - ddy) * (y < obsy2 + ddy) * (x > obsx) * (x < obsx + dx) * (z > obsz - ddz) * (z < obsz + ddz)
Eobs3b.reduced_function(x,y,z) = (y >  obsy3 - ddy) * (y < obsy3 + ddy) * (x > obsx) * (x < obsx + dx) * (z > obsz - ddz) * (z < obsz + ddz)
Eobs4b.reduced_function(x,y,z) = (y >  obsy4 - ddy) * (y < obsy4 + ddy) * (x > obsx) * (x < obsx + dx) * (z > obsz - ddz) * (z < obsz + ddz)
Eobs5b.reduced_function(x,y,z) = (y >  obsy5 - ddy) * (y < obsy5 + ddy) * (x > obsx) * (x < obsx + dx) * (z > obsz - ddz) * (z < obsz + ddz)

